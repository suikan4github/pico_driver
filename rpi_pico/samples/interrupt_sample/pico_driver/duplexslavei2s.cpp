#include "duplexslavei2s.hpp"

#include "sdkwrapper.hpp"

#if __has_include(<hardware/pio.h>)  // Is build in Pico Environment?
extern "C" {
#include "duplex_slave_i2s.h"  // Generated by PIO compiler.
}
#else
#define duplex_slave_i2s_program_get_default_config(config) 1
#define clk_sys 1
static pio_program_t duplex_slave_i2s_program;
#endif  // __has_include(<hardware/pio.h>)

pico_driver::DuplexSlaveI2S::DuplexSlaveI2S(::pico_driver::SDKWrapper &sdk,
                                            PIO pio, uint pin_base)
    : sdk_(sdk),
      pio_(pio),
      sm_(sdk_.pio_claim_unused_sm(
          pio_, true)),  // true mean required. assert if no room.
      pin_base_(pin_base) {}

pico_driver::DuplexSlaveI2S::DuplexSlaveI2S(::pico_driver::SDKWrapper &sdk,
                                            PIO pio, uint32_t sm, uint pin_base)
    : sdk_(sdk), pio_(pio), sm_(sm), pin_base_(pin_base) {
  sdk_.pio_sm_claim(pio_, sm_);
}

pico_driver::DuplexSlaveI2S::~DuplexSlaveI2S() {
  if (sdk_.pio_sm_is_claimed(pio_, sm_)) sdk_.pio_sm_unclaim(pio_, sm_);
}

uint32_t pico_driver::DuplexSlaveI2S::GetStateMachine() { return sm_; }

void pico_driver::DuplexSlaveI2S::Start() {
  // PIO configuration. Set SDOUT as
  // output. Set SDIN, BCLK and WS as
  // input.
  sdk_.pio_sm_set_consecutive_pindirs(pio_, sm_,
                                      pin_base_,  // BASE GPIO pin number.
                                      1,          // 1 pin for output.
                                      true);      // true for output.
  sdk_.pio_sm_set_consecutive_pindirs(pio_, sm_,
                                      pin_base_ + 1,  // BASE GPIO pin number.
                                      3,              // 3 pins for input.
                                      false);         // false for input.

  // Use thse four pins by PIO.
  sdk_.pio_gpio_init(pio_, pin_base_);
  sdk_.pio_gpio_init(pio_, pin_base_ + 1);
  sdk_.pio_gpio_init(pio_, pin_base_ + 2);
  sdk_.pio_gpio_init(pio_, pin_base_ + 3);

  uint instruction_offset =
      sdk_.pio_add_program(pio_, &duplex_slave_i2s_program);

  // State machine configuration.
  // The duplex_i2s_program_get_default_config() is generated by the
  // PIO compiler. So, there is not wrapper.
  pio_sm_config config =
      duplex_slave_i2s_program_get_default_config(instruction_offset);

  // Set direction of pins.
  sdk_.sm_config_set_out_pins(&config,
                              pin_base_,  // PIN_SDOUT
                              1);         // 1 pin for output.
  sdk_.sm_config_set_in_pin_base(&config,
                                 pin_base_ + 1);  // PIN_SDIN.
  sdk_.sm_config_set_in_pin_count(&config,
                                  2);                  // 2 pins for input.
  sdk_.sm_config_set_jmp_pin(&config, pin_base_ + 3);  // WS

  // Set the PIO clock divider.
  // We need 96kHz stereo 32bit transfer. So the BCLCK is 96'000*2*32Hz.
  // The  clock for the duplex I2S PIO program must be 10 times or grather
  // ( See the comment in the duplex_i2s.pio_ ).
  // To avoid the jitter, we calculate the division factor in
  // integer.
  float div = (sdk_.clock_get_hz(clk_sys) / (96'000 * 2 * 32 * 10));
  sdk_.sm_config_set_clkdiv(&config, div);

  // Shift configuration : No Auto push/pull.
  // Input shift register.
  sdk_.sm_config_set_in_shift(&config,
                              false,  // false to left shift.
                              false,  // true to auto push.
                              32);    // 32bit word.
  // Output shift register.
  sdk_.sm_config_set_out_shift(&config,
                               false,  // false to left shift.
                               false,  // true to auto pull.
                               32);    // 32bit word.

  // Configure SM.
  sdk_.pio_sm_init(pio_, sm_, instruction_offset, &config);

  // Placing dummy data in FIFO to avoid the underflow at first TX.
  // This must be done after calling pio_sm_init().
  // We need 2 stereo samples.
  // The first stereo sample is for the initial transfer. For this transfer,
  // main program is waiting the received signal. So, we need to fill dummy.
  // After the first data transfer, the main routine starts to process data.
  // We need time for max 1 sample. Then, we need to fill another dummy.
  sdk_.pio_sm_put(pio_, sm_, 0);  // Put left word for the first TX.
  sdk_.pio_sm_put(pio_, sm_, 0);  // Put right word for the first TX.
  sdk_.pio_sm_put(pio_, sm_, 0);  // Put left word for the second TX.
  sdk_.pio_sm_put(pio_, sm_, 0);  // Put right word for the second TX.

  // Start the state machine.
  sdk_.pio_sm_set_enabled(pio_, sm_, true);
}

void pico_driver::DuplexSlaveI2S::Stop() { sdk_.pio_sm_unclaim(pio_, sm_); }
